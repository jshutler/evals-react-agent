# Code Generated by Sidekick is for learning and experimentation purposes only.

from typing import Dict, List
import json
from langchain_anthropic import ChatAnthropic
from langchain.schema import (
    SystemMessage,
    HumanMessage,
)
from langchain_core.messages import ToolMessage
from dotenv import load_dotenv
from anthropic import Anthropic
from langchain.tools import Tool
from pydantic import BaseModel, Field
import os
from models import FinalReport, DAOGetAllTables, DAOGetSchemaForTable, DAORunSQL
from dotenv import load_dotenv
from sqlalchemy_utils.sales_dao import SalesDAO
from db_constants import SALES_DB_CONNECTION_STRING

load_dotenv()


# Map tool name string <-> callable
TOOLS: Dict[str, BaseModel] = {
    "DAOGetAllTables": DAOGetAllTables,
    "DAOGetSchemaForTable": DAOGetSchemaForTable,
    "DAORunSQL": DAORunSQL,
    "FinalReport": FinalReport,
}


def execute_tool(name: str, arguments: dict, tools: Dict[str, BaseModel], dao: SalesDAO = None) -> str:
    """Runs a tool and returns the observation with correct prefix."""
    model_cls = tools[name]
    
    if name.lower().startswith("dao"):
        # For DAO tools, create the model and pass dao to __call__
        model = model_cls(**arguments)
        result = model(dao)
    else:
        # For non-DAO tools, use the original approach
        result = model_cls(**arguments)()
    
    return f"Observation: {result}"


# -------------------------- 2. planning agent  --------------------------------
PLAN_PROMPT = """You are a planning agent. 
Given a user question and the tool list, produce numbered tasks.
Tools: {tool_list}
Question: {query}

IMPORTANT: The FINAL task in your plan must ALWAYS be 'finalreport' to properly complete the execution.

Return plain text only, format: 
Task 1: <desc> -- <tool_name>
...
Task N: Compile final results and recommendations -- finalreport
"""

def make_plan(llm: ChatAnthropic, 
              query: str, 
              tools: Dict[str, BaseModel], 
              plan_prompt_template: str
              ) -> str:
    tool_list = ", ".join(tools.keys())
    plan_prompt = plan_prompt_template.format(tool_list=tool_list, query=query)
    return llm.invoke(plan_prompt).content


# -------------------------- 3. action agent spec (JSON mode) ------------------

def build_tool_specs(tools: Dict[str, BaseModel]) -> List[Dict]:
    specs = []
    for name, cls in tools.items():
        specs.append(
            {
                "name": name,
                "description": cls.__doc__ or "",
                "input_schema": cls.model_json_schema(),   
            }
        )
    return specs

FUNCTION_SPEC = build_tool_specs(TOOLS) 




ACTION_SYSTEM = """
You are an execution agent that must follow the given plan.
If a tool is required, return tool name and arguments.
The LAST task must ALWAYS be 'finalreport' to properly finish the execution.
When using finalreport tool, include a comprehensive summary of what you've done and your recommendations.
Only after completing the finalreport task should you consider all tasks finished.
Remember: respond ONLY with JSON compatible with the function schema.
"""

def get_action_message(plan: str, workpad: str, query: str) -> str:
    return f"""
            User Query: {query}
            Plan:
            {plan}

            Workpad so far:
            {workpad}
            """

def anthropic_parse_response_for_tool(response: str) -> tuple[str, dict]:
    tool_name = response.tool_calls[0]["name"]
    tool_args = response.tool_calls[0]["args"]
    tool_call_id = response.tool_calls[0]["id"]
    return tool_name, tool_args, tool_call_id

# -------------------------- 4.  driver loop  ----------------------------------
def run_react_agent(llm: ChatAnthropic, query: str, tools, dao: SalesDAO) -> str:
    llm_with_tools = llm.bind_tools(list(tools.values()))
    plan = make_plan(llm, query, tools, PLAN_PROMPT)
    print("Plan:\n", plan)

    # running log that we show the model each turn
    workpad: List[str] = []

    messages = [
        SystemMessage(content=ACTION_SYSTEM),
    ]

    max_iters = 15
    for _ in range(max_iters):
        # breakpoint()
        user_msg = HumanMessage(content=get_action_message(plan, "\n".join(workpad), query))
        messages.append(user_msg)
        
        response = llm_with_tools.invoke(messages)
        tool_name, tool_args, tool_call_id = anthropic_parse_response_for_tool(response)
        validated_data = tools[tool_name].model_validate(tool_args)
        messages.append(response)

        # Check if this is the final report
        if tool_name == "FinalReport":
            observation = execute_tool(tool_name, tool_args, TOOLS, dao)
            print(f"Executed {tool_name} -> {observation}")
            
            workpad.append(f"Final Report: {observation}")
            final_result = f"Final Report: {json.dumps(validated_data(), indent=2)}"
            print("\nCompleted execution with final report")
            return final_result, workpad

        # Otherwise, continue with normal tool execution
        observation = execute_tool(tool_name, tool_args, TOOLS, dao)
        print(f"Executed {tool_name} -> {observation}")

        workpad.append(
            f"Task executed via {tool_name} input={tool_args}\n{observation}"
        )
        messages.append(ToolMessage(content=observation, tool_call_id=tool_call_id))

    raise RuntimeError("Hit max iterations without final answer.")


if __name__ == "__main__":
    llm = ChatAnthropic(model="claude-3-haiku-20240307", api_key=os.environ["ANTHROPIC_API_KEY"])
    
    dao = SalesDAO(SALES_DB_CONNECTION_STRING)  
    
    query = f"I would like to know who has made transactions in the database as of right now."
    final_answer, workpad = run_react_agent(llm, query, TOOLS, dao)
    breakpoint()
    print(f"Final Answer: {final_answer}")
